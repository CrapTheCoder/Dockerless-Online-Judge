# In app/crud/crud_submission.py

import json
import uuid  # Import uuid for UUID handling
import traceback  # Import traceback for detailed error logging
from typing import List, Optional, Dict, Any # Added Any for get ID type hint

from sqlalchemy import desc
from sqlalchemy.orm import Session
from pydantic import BaseModel # Assuming BaseModel is used by schemas

# Adjust these imports based on your project structure
from app.crud.base import CRUDBase
from app.db.models import Submission # Assuming your Submission model is here
# Assuming you have SubmissionCreate and SubmissionUpdate schemas
from app.schemas.submission import SubmissionCreate, SubmissionUpdate, TestCaseResult


# Assuming your CRUDBase handles basic type hinting
# We'll override get specifically to handle UUID strings correctly
class CRUDSubmission(CRUDBase[Submission, SubmissionCreate, SubmissionUpdate]):

    # Override the generic get to explicitly handle UUID strings
    def get(self, db: Session, id_: Any) -> Optional[Submission]:
        """ Get a submission by its ID, handling UUID conversion if necessary. """
        # Your model uses String for the ID column but stores UUID strings.
        # We'll query using the string representation directly, as SQLAlchemy
        # should handle filtering on a string column.
        # We still validate it looks like a UUID just in case.
        if isinstance(id_, uuid.UUID):
             # Convert UUID object to string for querying the String column
             id_str = str(id_)
        elif isinstance(id_, str):
             id_str = id_
             # Optional: Validate if the string is a valid UUID format
             try:
                 uuid.UUID(id_str) # Just validate format
             except ValueError:
                 print(f"CRUD: Invalid UUID string format provided to get: {id_str}")
                 return None # Invalid UUID string format
        else:
             print(f"CRUD: Unexpected ID type for get: {type(id_)}")
             return None # Unexpected type

        print(f"CRUD: Fetching submission with ID string: {id_str}")
        return db.query(self.model).filter(self.model.id == id_str).first()


    def create_with_owner(
            self, db: Session, *, obj_in: SubmissionCreate, submitter_id: int # Assuming submitter_id is int
    ) -> Submission:
        """ Creates a new submission record, commits it, and returns the object with ID. """
        print("CRUD: In create_with_owner...")

        # Initialize results_json with an empty list representation
        results_list_for_json: List[Dict] = [] # Use Dict type hint for clarity

        # Create the SQLAlchemy model instance
        # Your model uses `default=lambda: str(uuid_pkg.uuid4())` for the ID,
        # so SQLAlchemy generates the ID string when `db.add` is called.
        db_obj = Submission(
            problem_id=obj_in.problem_id,
            contest_id=obj_in.contest_id,
            language=obj_in.language,
            code=obj_in.code,
            submitter_id=submitter_id, # Assuming User ID is int
            status="PENDING", # Set initial status string
            results_json=json.dumps(results_list_for_json) # Store empty results initially
            # submitted_at is handled by model default
        )

        db.add(db_obj) # Add the object to the session

        # --- FIX: Add robust commit/refresh with error handling ---
        try:
            print("CRUD: Attempting to commit new submission...")
            db.commit() # Commit the transaction - this is where the row is inserted
            print("CRUD: Commit successful.")

            # Refresh the object to load its database-generated ID and other defaults (like submitted_at)
            # For String UUID generated by SQLAlchemy default, ID is available *before* refresh,
            # but refresh is still good practice for other potential defaults/triggers.
            db.refresh(db_obj)
            print(f"CRUD: Refresh successful. New submission ID: {db_obj.id}")

            return db_obj # Return the db_obj with the now-populated ID

        except Exception as e:
            # Log the full traceback for the error
            print(f"CRUD: ERROR during commit/refresh of new submission:")
            traceback.print_exc()
            db.rollback() # Rollback the transaction on any error during add/commit/refresh
            # Re-raise the exception so the service layer knows it failed
            raise


    def get_multi_by_owner(
            self, db: Session, *, submitter_id: int, skip: int = 0, limit: int = 100
    ) -> List[Submission]:
        """ Gets multiple submissions for a specific owner, ordered by submission time. """
        # Ensure submitter_id is filtered correctly based on the model field type (int)
        return (
            db.query(self.model)
            .filter(Submission.submitter_id == submitter_id)
            .order_by(desc(Submission.submitted_at)) # Assumes 'submitted_at' field exists
            .offset(skip)
            .limit(limit)
            .all()
        )

    def update_submission_results(
            self,
            db: Session,
            *,
            db_obj: Submission, # Expecting a session-bound Submission object
            status: str, # Expecting status as string
            results: List[TestCaseResult]
    ) -> Submission:
        """ Updates the status and results_json for an existing submission and commits. """
        print(f"CRUD: In update_submission_results for ID: {db_obj.id}")

        # Ensure the db_obj is still attached to the session, or re-attach/merge if needed
        # This is crucial for objects fetched in a different context (like a worker's new session)
        try:
            db.merge(db_obj) # Merge the object into the current session
            print(f"CRUD: Merged db_obj {db_obj.id} into session.")
        except Exception as e:
             print(f"CRUD: ERROR merging db_obj {db_obj.id}: {e}")
             # Decide how to handle merge failure - often indicates a critical issue
             db.rollback()
             raise

        results_list_of_dicts = [result.model_dump() for result in results]
        db_obj.results_json = json.dumps(results_list_of_dicts)
        db_obj.status = status # Update the status field

        # No need for db.add(db_obj) after merge
        # db.add(db_obj) # This line can often be removed after merge

        # --- Add robust commit with error handling ---
        try:
            print(f"CRUD: Attempting to commit update for submission ID: {db_obj.id}...")
            db.commit() # Commit the transaction - this saves the updates
            print(f"CRUD: Commit successful for update of submission ID: {db_obj.id}")

            # Refresh the object in case of DB triggers or other updates (less common for simple updates)
            # db.refresh(db_obj) # Optional refresh

            return db_obj # Return the updated db_obj

        except Exception as e:
            # Log the full traceback for the error
            print(f"CRUD: ERROR during commit of submission update for ID {db_obj.id}:")
            traceback.print_exc()
            db.rollback() # Rollback the transaction on any error during the update
            # Re-raise the exception
            raise


    def get_submission_with_owner_info(self, db: Session, id: str, submitter_id: int) -> Optional[Submission]:
        """ Get a specific submission by ID, ensuring it belongs to the specified owner, handling UUID. """
        print(f"CRUD: In get_submission_with_owner_info for ID: {id}")
        # Your model uses String for the ID column but stores UUID strings.
        # We query using the string representation directly.
        # Validate if the string is a valid UUID format just in case.
        try:
            uuid.UUID(id) # Just validate format
        except ValueError:
            print(f"CRUD: Invalid UUID string format for ID: {id}")
            return None # Invalid UUID format

        # Ensure filtering on both ID (string UUID) and submitter_id (int)
        return (
            db.query(self.model)
            .filter(self.model.id == id, self.model.submitter_id == submitter_id)
            .first()
        )


# Instantiate the CRUD object
submission = CRUDSubmission(Submission)